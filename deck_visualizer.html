<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deck Layout Visualizer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            min-height: 100vh;
        }
        
        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            margin: 0;
            padding: 0;
        }
        
        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 320px;
            max-height: 70vh;
            background: linear-gradient(145deg, rgba(255,255,255,0.15) 0%, rgba(248,249,250,0.1) 100%);
            padding: 0;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(20px) saturate(180%);
            z-index: 1000;
            overflow-y: auto;
        }
        
        .controls-header {
            position: sticky;
            top: 0;
            background: linear-gradient(145deg, rgba(100,149,237,0.3) 0%, rgba(70,130,180,0.25) 100%);
            color: rgba(0,0,0,0.9);
            padding: 15px 20px;
            border-radius: 16px 16px 0 0;
            cursor: pointer;
            user-select: none;
            font-weight: 600;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15), inset 0 1px 0 rgba(255,255,255,0.1);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
        }
        
        .controls-header:hover {
            background: linear-gradient(145deg, rgba(100,149,237,0.4) 0%, rgba(70,130,180,0.35) 100%);
        }
        
        .controls-content {
            padding: 20px;
            max-height: calc(70vh - 60px);
            overflow-y: auto;
            transition: max-height 0.3s ease-out;
            background: rgba(255,255,255,0.05);
            backdrop-filter: blur(5px);
        }
        
        .controls-content.collapsed {
            max-height: 0;
            padding: 0 20px;
            overflow: hidden;
        }
        
        .controls-header:not(:first-child) {
            background: linear-gradient(145deg, rgba(255,255,255,0.1) 0%, rgba(248,249,250,0.05) 100%);
            color: rgba(0,0,0,0.9);
            border-radius: 8px;
            margin: 10px 0 5px 0;
            padding: 12px 15px;
            font-size: 14px;
            border: 1px solid rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
        }
        
        .controls-header:not(:first-child):hover {
            background: linear-gradient(145deg, rgba(255,255,255,0.15) 0%, rgba(248,249,250,0.1) 100%);
        }
        
        .control-group {
            margin-bottom: 18px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 6px;
            font-weight: 600;
            color: rgba(0,0,0,0.9);
            font-size: 14px;
            text-shadow: 0 1px 2px rgba(255,255,255,0.3);
        }
        
        .control-group input, .control-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            box-sizing: border-box;
            font-size: 14px;
            transition: all 0.3s ease;
            background: rgba(255,255,255,0.1);
            color: rgba(0,0,0,0.9);
            backdrop-filter: blur(10px);
        }
        
        .control-group input:focus, .control-group select:focus {
            outline: none;
            border-color: rgba(100,149,237,0.6);
            box-shadow: 0 0 0 3px rgba(100,149,237,0.2);
            background: rgba(255,255,255,0.15);
        }
        
        .canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #2a2a2a;
            padding: 20px;
            box-sizing: border-box;
        }
        
        #deckCanvas {
            border: 2px solid rgba(255,255,255,0.15);
            border-radius: 12px;
            cursor: grab;
            display: block;
            margin: 0 auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4), 
                        inset 0 1px 0 rgba(255,255,255,0.1);
            background: #a8c186;
        }
        
        #deckCanvas:active {
            cursor: grabbing;
        }
        
        .button {
            width: 100%;
            padding: 12px;
            background: linear-gradient(145deg, rgba(100,149,237,0.3) 0%, rgba(70,130,180,0.25) 100%);
            color: rgba(0,0,0,0.9);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            margin-top: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
        }
        
        .button:hover {
            background: linear-gradient(145deg, rgba(100,149,237,0.4) 0%, rgba(70,130,180,0.35) 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        .button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
        
        .pattern-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }
        
        .pattern-buttons button {
            padding: 8px;
            font-size: 12px;
            margin-top: 5px;
        }
        
        .info {
            background: linear-gradient(145deg, rgba(255,255,255,0.1) 0%, rgba(248,249,250,0.05) 100%);
            padding: 16px;
            border-radius: 10px;
            margin-top: 15px;
            font-size: 13px;
            line-height: 1.6;
            border: 1px solid rgba(255,255,255,0.15);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            color: rgba(0,0,0,0.85);
            backdrop-filter: blur(10px);
        }
        
        .floating-input {
            position: absolute;
            background: linear-gradient(145deg, rgba(255,255,255,0.15) 0%, rgba(248,249,250,0.1) 100%);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 16px;
            padding: 0;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3), inset 0 1px 0 rgba(255,255,255,0.2);
            backdrop-filter: blur(20px) saturate(180%);
            z-index: 1000;
            display: none;
            min-width: 220px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            cursor: move;
        }
        
        .floating-input .title-bar {
            margin: 0;
            padding: 15px 20px;
            background: linear-gradient(145deg, rgba(100,149,237,0.3) 0%, rgba(70,130,180,0.25) 100%);
            color: rgba(0,0,0,0.9);
            font-weight: 600;
            font-size: 14px;
            border-radius: 16px 16px 0 0;
            cursor: move;
            user-select: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15), inset 0 1px 0 rgba(255,255,255,0.1);
            border-bottom: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
        }
        
        .dimension-row {
            display: flex;
            align-items: center;
            margin: 8px 0;
            gap: 8px;
        }
        
        .dimension-label {
            width: 50px;
            font-weight: 600;
            font-size: 14px;
            color: rgba(0,0,0,0.9);
            text-shadow: 0 1px 2px rgba(255,255,255,0.3);
        }
        
        .dimension-controls {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .dimension-input {
            width: 60px;
            padding: 8px 10px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            font-size: 14px;
            text-align: center;
            background: rgba(255,255,255,0.1);
            color: rgba(0,0,0,0.9);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .increment-btn {
            width: 28px;
            height: 28px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.1);
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(0,0,0,0.9);
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .increment-btn:hover {
            background: rgba(255,255,255,0.15);
            transform: translateY(-1px);
        }
        
        .floating-input .action-buttons {
            display: flex;
            gap: 8px;
            margin: 20px;
            margin-top: 15px;
            justify-content: flex-end;
        }
        
        .floating-input button {
            padding: 10px 16px;
            font-size: 14px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .floating-input .ok-btn {
            background: #49b15e;
            color: white;
        }
        
        .floating-input .cancel-btn {
            background: linear-gradient(145deg, rgba(244,67,54,0.3) 0%, rgba(211,47,47,0.25) 100%);
            color: rgba(0,0,0,0.9);
        }
        
        .floating-input .cancel-btn:hover {
            background: linear-gradient(145deg, rgba(244,67,54,0.4) 0%, rgba(211,47,47,0.35) 100%);
            transform: translateY(-2px);
        }
    </style>
</head>
<body>

    <div class="container">
        <div class="controls">
            <div class="controls-header" onclick="toggleMainPanel()">
                🔧 Deck Controls
                <span id="mainToggle">▼</span>
            </div>
            <div id="mainControls" class="controls-content">
                
                <div class="controls-header" onclick="toggleSection('deck-dimensions')">Deck Dimensions ▶</div>
                <div id="deck-dimensions" class="controls-content collapsed">
                    <div class="control-group">
                        <label>Top Edge (ft):</label>
                        <input type="number" id="topEdge" value="24" min="4" max="30" step="0.5">
                    </div>
                    <div class="control-group">
                        <label>Right Edge (ft):</label>
                        <input type="number" id="rightEdge" value="12" min="4" max="30" step="0.5">
                    </div>
                    <div class="control-group">
                        <label>Bottom Edge (ft):</label>
                        <input type="number" id="bottomEdge" value="24" min="4" max="30" step="0.5">
                    </div>
                    <div class="control-group">
                        <label>Left Edge (ft):</label>
                        <input type="number" id="leftEdge" value="12" min="4" max="30" step="0.5">
                    </div>
                    <div class="control-group">
                        <label>Extension Width (ft):</label>
                        <input type="number" id="extWidth" value="8" min="0" max="20" step="0.5">
                    </div>
                    <div class="control-group">
                        <label>Extension Length (ft):</label>
                        <input type="number" id="extLength" value="4" min="0" max="20" step="0.5">
                    </div>
                </div>
                
                <div class="controls-header" onclick="toggleSection('grid-settings')">Grid Settings</div>
                <div id="grid-settings" class="controls-content collapsed">
                    <div class="control-group">
                        <label>Grid Size:</label>
                        <select id="gridSize">
                            <option value="0.0104">1/8" (0.0104 ft)</option>
                            <option value="0.0208">1/4" (0.0208 ft)</option>
                            <option value="0.0417">1/2" (0.0417 ft)</option>
                            <option value="0.0833">1" (0.0833 ft)</option>
                            <option value="0.1667">2" (0.1667 ft)</option>
                            <option value="0.25">3" (0.25 ft)</option>
                            <option value="0.5">6" (0.5 ft)</option>
                            <option value="1" selected>1 foot</option>
                            <option value="2">2 feet</option>
                            <option value="4">4 feet</option>
                            <option value="custom">Custom...</option>
                        </select>
                    </div>
                    <div class="control-group" id="customGridGroup" style="display: none;">
                        <label>Custom Grid Size:</label>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <input type="number" id="customGridSize" value="1" min="0.0104" max="10" step="0.0001" style="width: 80px;">
                            <select id="gridUnit" style="width: 60px;">
                                <option value="inches">inches</option>
                                <option value="feet" selected>feet</option>
                            </select>
                        </div>
                    </div>
                    <div class="control-group">
                        <label>Show Grid:</label>
                        <input type="checkbox" id="showGrid" checked>
                    </div>
                    <div class="control-group">
                        <label>Snap to Grid (1/8"):</label>
                        <input type="checkbox" id="snapToGrid" checked>
                    </div>
                </div>
                
                <div class="controls-header" onclick="toggleSection('joist-settings')">Joist Settings</div>
                <div id="joist-settings" class="controls-content collapsed">
                    <div class="control-group">
                        <label>Joist Spacing (inches):</label>
                        <select id="joistSpacing">
                            <option value="12">12" O.C.</option>
                            <option value="16" selected>16" O.C.</option>
                            <option value="19.2">19.2" O.C.</option>
                            <option value="24">24" O.C.</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Joist Direction:</label>
                        <select id="joistDirection">
                            <option value="horizontal">Horizontal</option>
                            <option value="vertical" selected>Vertical</option>
                        </select>
                    </div>
                </div>
                
                <div class="controls-header" onclick="toggleSection('board-settings')">Board Settings</div>
                <div id="board-settings" class="controls-content collapsed">
                    <div class="control-group">
                        <label>Board Width (inches):</label>
                        <select id="boardWidth">
                            <option value="3.5">2x4 (3.5")</option>
                            <option value="5.5" selected>2x6 (5.5")</option>
                            <option value="7.25">2x8 (7.25")</option>
                            <option value="1">1" Composite</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Board Gap (inches):</label>
                        <input type="number" id="boardGap" value="0.125" min="0" max="0.5" step="0.125">
                    </div>
                    <div class="control-group">
                        <label>Board Length (ft):</label>
                        <input type="number" id="boardLength" value="8" min="2" max="20" step="0.5">
                    </div>
                </div>
                
                <div class="controls-header" onclick="toggleSection('board-management')">Board Management</div>
                <div id="board-management" class="controls-content collapsed">
                    <div class="control-group">
                        <label>Number of Boards:</label>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <input type="number" id="boardCount" value="0" min="0" max="100" readonly style="width: 60px;">
                            <button onclick="addMultipleBoards(5)" style="padding: 5px 10px; font-size: 12px;">+5</button>
                            <button onclick="addMultipleBoards(10)" style="padding: 5px 10px; font-size: 12px;">+10</button>
                            <button onclick="removeSelectedBoards()" style="padding: 5px 10px; font-size: 12px;">Remove</button>
                        </div>
                    </div>
                </div>
                
                <div class="controls-header" onclick="toggleSection('board-layout')">Board Layout</div>
                <div id="board-layout" class="controls-content collapsed">
                    <div class="control-group">
                        <label>Board Direction:</label>
                        <select id="boardDirection">
                            <option value="horizontal">Horizontal</option>
                            <option value="vertical" selected>Vertical</option>
                        </select>
                    </div>
                    
                    <button class="button" onclick="applyPattern('straight')">Fill with Straight Boards</button>
                    <button class="button" onclick="resetLayout()">Reset Layout</button>
                    <button class="button" onclick="addRandomBoard()">Add Board</button>
                </div>
                
                <div class="controls-header" onclick="toggleSection('instructions')">📖 Instructions & Help</div>
                <div id="instructions" class="controls-content collapsed">
                    <div class="info">
                        <strong>🎯 Basic Controls:</strong><br>
                        • Click blue edge handles to edit deck dimensions<br>
                        • <strong>Double-click</strong> boards to edit their size<br>
                        • Click and drag boards to reposition<br>
                        • Right-click boards to rotate<br>
                        • Drag empty space to box-select multiple boards<br>
                        • Hold Ctrl/Cmd + click to add/remove from selection<br><br>
                        
                        <strong>🔍 Navigation:</strong><br>
                        • <strong>Shift + drag</strong> or <strong>middle mouse</strong> to pan around<br>
                        • <strong>Mouse wheel</strong> to scroll (panning coming soon)<br>
                        • <strong>Box select</strong> by dragging in empty space<br><br>
                        
                        <strong>⌨️ Keyboard Shortcuts:</strong><br>
                        • <strong>Ctrl+C</strong> to copy, <strong>Ctrl+V</strong> to paste boards<br>
                        • <strong>Ctrl+D</strong> to duplicate selected boards<br>
                        • <strong>Ctrl+Z</strong> to undo last action<br>
                        • <strong>Delete/Backspace</strong> to remove selected boards<br><br>
                        
                        <strong>🔧 Advanced Features:</strong><br>
                        • Use +5/+10 buttons to add multiple boards<br>
                        • Choose horizontal or vertical board direction<br>
                        • Drag the title bar of edit windows to move them<br>
                        • <strong>Grid Settings</strong>: Use presets or "Custom" for precise grid sizes (down to 1/8")<br>
                        • <strong>Snap to Grid</strong>: All boards automatically snap to 1/8" precision for perfect alignment<br>
                        • <strong>Smart Snapping</strong>: Boards snap to deck edges and other boards when dragged nearby
                    </div>
                </div>
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="deckCanvas" width="1600" height="900"></canvas>
            
            <!-- Floating input for editing dimensions -->
            <div id="floatingInput" class="floating-input">
                <div class="title-bar" id="titleBar">Edit Dimensions</div>
                <div style="padding: 20px; padding-bottom: 0;">
                    <div id="inputLabel" style="font-weight: 600; margin-bottom: 15px; color: rgba(0,0,0,0.9); font-size: 16px;">Edit Board Dimensions:</div>
                
                <div class="dimension-row">
                    <div class="dimension-label">Width:</div>
                    <div class="dimension-controls">
                        <button class="increment-btn" onclick="adjustDimension('width', -0.5)">−</button>
                        <input type="number" id="widthInput" class="dimension-input" step="0.5" min="0.5">
                        <button class="increment-btn" onclick="adjustDimension('width', 0.5)">+</button>
                        <span style="font-size: 11px; color: #666;">inches</span>
                    </div>
                </div>
                
                <div class="dimension-row">
                    <div class="dimension-label">Length:</div>
                    <div class="dimension-controls">
                        <button class="increment-btn" onclick="adjustDimension('length', -0.5)">−</button>
                        <input type="number" id="lengthInput" class="dimension-input" step="0.5" min="0.5">
                        <button class="increment-btn" onclick="adjustDimension('length', 0.5)">+</button>
                        <span style="font-size: 11px; color: #666;">feet</span>
                    </div>
                </div>
                
                <div class="dimension-row" id="edgeInputRow" style="display: none;">
                    <div class="dimension-label">Size:</div>
                    <div class="dimension-controls">
                        <button class="increment-btn" onclick="adjustDimension('edge', -0.5)">−</button>
                        <input type="number" id="edgeInput" class="dimension-input" step="0.5" min="0.5">
                        <button class="increment-btn" onclick="adjustDimension('edge', 0.5)">+</button>
                        <span style="font-size: 11px; color: #666;">feet</span>
                    </div>
                </div>
                
                </div>
                
                <div class="action-buttons">
                    <button class="ok-btn" onclick="applyFloatingInput()">Apply</button>
                    <button class="cancel-btn" onclick="hideFloatingInput()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        class DeckVisualizer {
            constructor() {
                this.canvas = document.getElementById('deckCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Make canvas responsive to full screen
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                this.scale = 30; // pixels per foot
                this.boards = [];
                this.selectedBoard = null;
                this.selectedBoards = [];
                this.isDragging = false;
                this.isBoxSelecting = false;
                this.dragOffset = { x: 0, y: 0 };
                this.boxStart = { x: 0, y: 0 };
                this.boxEnd = { x: 0, y: 0 };
                this.edgeHandles = [];
                this.selectedEdge = null;
                this.isResizing = false;
                this.editingTarget = null;
                this.editingType = null;
                this.clipboard = [];
                this.isDraggingDialog = false;
                this.dialogDragOffset = { x: 0, y: 0 };
                
                // Panning functionality
                this.isPanning = false;
                this.panOffset = { x: 0, y: 0 };
                this.panStart = { x: 0, y: 0 };
                this.viewOffset = { x: 0, y: 0 };
                
                // Snap-to-grid settings
                this.snapGridSize = 1/8 / 12; // 1/8 inch in feet
                this.snapEnabled = true; // Re-enable snapping
                
                // Undo functionality
                this.undoStack = [];
                this.maxUndoSteps = 50;
                
                this.initEventListeners();
                this.updateLayout();
            }
            
            initEventListeners() {
                // Canvas events
                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
                this.canvas.addEventListener('contextmenu', this.handleRightClick.bind(this));
                this.canvas.addEventListener('wheel', this.handleWheel.bind(this));
                
                // Change cursor for edge handles and panning
                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.isPanning) return; // Don't change cursor while panning
                    
                    const rect = this.canvas.getBoundingClientRect();
                    const screenX = e.clientX - rect.left;
                    const screenY = e.clientY - rect.top;
                    const worldPos = this.screenToWorld(screenX, screenY);
                    const edge = this.getEdgeAtPoint(worldPos.x, worldPos.y);
                    
                    if (e.shiftKey) {
                        this.canvas.style.cursor = 'grab';
                    } else {
                        this.canvas.style.cursor = edge ? 'pointer' : 'grab';
                    }
                });
                
                // Dialog dragging functionality
                this.initDialogDragging();
                
                // Control events
                ['topEdge', 'rightEdge', 'bottomEdge', 'leftEdge', 'extWidth', 'extLength', 'joistSpacing', 'joistDirection', 'boardWidth', 'boardGap', 'boardLength', 'gridSize', 'showGrid', 'customGridSize', 'gridUnit', 'snapToGrid'].forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('change', () => this.updateLayout());
                    }
                });
                
                // Special handler for snap toggle
                document.getElementById('snapToGrid').addEventListener('change', (e) => {
                    this.snapEnabled = e.target.checked;
                });
                
                // Special handler for grid size dropdown to show/hide custom input
                document.getElementById('gridSize').addEventListener('change', (e) => {
                    const customGroup = document.getElementById('customGridGroup');
                    if (e.target.value === 'custom') {
                        customGroup.style.display = 'block';
                    } else {
                        customGroup.style.display = 'none';
                    }
                    this.updateLayout();
                });
            }
            
            updateLayout() {
                this.drawDeck();
            }
            
            // Convert screen coordinates to world coordinates (accounting for panning)
            screenToWorld(screenX, screenY) {
                return {
                    x: screenX - this.viewOffset.x,
                    y: screenY - this.viewOffset.y
                };
            }
            
            // Convert world coordinates to screen coordinates
            worldToScreen(worldX, worldY) {
                return {
                    x: worldX + this.viewOffset.x,
                    y: worldY + this.viewOffset.y
                };
            }
            
            drawDeck() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Apply view transformation for panning
                this.ctx.save();
                this.ctx.translate(this.viewOffset.x, this.viewOffset.y);
                
                // Get dimensions
                const topEdge = parseFloat(document.getElementById('topEdge').value);
                const rightEdge = parseFloat(document.getElementById('rightEdge').value);
                const bottomEdge = parseFloat(document.getElementById('bottomEdge').value);
                const leftEdge = parseFloat(document.getElementById('leftEdge').value);
                const extWidth = parseFloat(document.getElementById('extWidth').value);
                const extLength = parseFloat(document.getElementById('extLength').value);
                
                // Draw grid first (behind everything)
                this.drawGrid();
                
                // Draw deck outline
                this.drawDeckOutline(topEdge, rightEdge, bottomEdge, leftEdge, extWidth, extLength);
                
                // Draw joists
                this.drawJoists(topEdge, rightEdge, bottomEdge, leftEdge, extWidth, extLength);
                
                // Draw boards
                this.boards.forEach(board => this.drawBoard(board));
                
                // Draw edge handles (with dimension labels on top)
                this.drawEdgeHandles(topEdge, rightEdge, bottomEdge, leftEdge, extWidth, extLength);
                
                // Draw selection box
                if (this.isBoxSelecting) {
                    this.drawSelectionBox();
                }
                
                // Restore transformation
                this.ctx.restore();
                
                // Update board count
                this.updateBoardCount();
            }
            
            drawDeckOutline(topEdge, rightEdge, bottomEdge, leftEdge, extWidth, extLength) {
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 3;
                this.ctx.fillStyle = '#f8f8f8';
                
                // Snap deck position to grid
                const baseX = 150;
                const baseY = 100;
                const snappedDeckPos = this.snapToGrid(baseX, baseY);
                const x = snappedDeckPos.x;
                const y = snappedDeckPos.y;
                
                const te = topEdge * this.scale;
                const re = rightEdge * this.scale;
                const be = bottomEdge * this.scale;
                const le = leftEdge * this.scale;
                const ew = extWidth * this.scale;
                const el = extLength * this.scale;
                
                // Draw main deck as irregular quadrilateral
                this.ctx.beginPath();
                this.ctx.moveTo(x, y);                    // top-left
                this.ctx.lineTo(x + te, y);               // top-right
                this.ctx.lineTo(x + te, y + re);          // bottom-right
                this.ctx.lineTo(x + te - be, y + re);     // bottom-left
                this.ctx.lineTo(x, y + le);               // back to start area
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.stroke();
                
                // Extension (if exists) - positioned extending from right edge
                if (extWidth > 0 && extLength > 0) {
                    this.ctx.fillRect(x + te, y + re - el, ew, el);
                    this.ctx.strokeRect(x + te, y + re - el, ew, el);
                }
            }
            
            drawJoists(topEdge, rightEdge, bottomEdge, leftEdge, extWidth, extLength) {
                const spacing = parseFloat(document.getElementById('joistSpacing').value) / 12; // Convert to feet
                const direction = document.getElementById('joistDirection').value;
                
                this.ctx.strokeStyle = '#8B4513';
                this.ctx.lineWidth = 2;
                
                // Use same snapped position as deck outline
                const baseX = 150;
                const baseY = 100;
                const snappedDeckPos = this.snapToGrid(baseX, baseY);
                const x = snappedDeckPos.x;
                const y = snappedDeckPos.y;
                
                const te = topEdge * this.scale;
                const re = rightEdge * this.scale;
                const ew = extWidth * this.scale;
                const el = extLength * this.scale;
                
                // Draw joists for main deck
                if (direction === 'vertical') {
                    // Vertical joists for main deck
                    for (let i = 0; i <= topEdge; i += spacing) {
                        const jx = x + i * this.scale;
                        this.ctx.beginPath();
                        this.ctx.moveTo(jx, y);
                        this.ctx.lineTo(jx, y + re);
                        this.ctx.stroke();
                    }
                    
                    // Vertical joists for extension (if exists)
                    if (extWidth > 0 && extLength > 0) {
                        for (let i = 0; i <= extWidth; i += spacing) {
                            const jx = x + te + i * this.scale;
                            this.ctx.beginPath();
                            this.ctx.moveTo(jx, y + re - el);
                            this.ctx.lineTo(jx, y + re);
                            this.ctx.stroke();
                        }
                    }
                } else {
                    // Horizontal joists for main deck
                    for (let i = 0; i <= rightEdge; i += spacing) {
                        const jy = y + i * this.scale;
                        this.ctx.beginPath();
                        this.ctx.moveTo(x, jy);
                        this.ctx.lineTo(x + te, jy);
                        this.ctx.stroke();
                    }
                    
                    // Horizontal joists for extension (if exists)
                    if (extWidth > 0 && extLength > 0) {
                        // Draw horizontal joists in the extension area
                        const extStartY = y + re - el;
                        for (let i = 0; i <= extLength; i += spacing) {
                            const jy = extStartY + i * this.scale;
                            this.ctx.beginPath();
                            this.ctx.moveTo(x + te, jy);
                            this.ctx.lineTo(x + te + ew, jy);
                            this.ctx.stroke();
                        }
                    }
                }
            }
            
            drawBoard(board) {
                this.ctx.save();
                this.ctx.translate(board.x, board.y);
                this.ctx.rotate(board.rotation);
                
                const w = board.width;
                const h = board.height;
                
                // Board color based on selection
                const isSelected = board.selected || this.selectedBoards.includes(board);
                
                // Draw shadow first
                this.ctx.save();
                this.ctx.translate(2, 2);
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                this.ctx.fillRect(-w/2, -h/2, w, h);
                this.ctx.restore();
                
                // Main board color - realistic wood tones
                if (isSelected) {
                    this.ctx.fillStyle = '#FFD700'; // Gold when selected
                    this.ctx.strokeStyle = '#FF6600';
                    this.ctx.lineWidth = 3;
                } else {
                    // Create gradient for wood appearance
                    const gradient = this.ctx.createLinearGradient(-w/2, -h/2, w/2, h/2);
                    gradient.addColorStop(0, '#D2B48C');    // Light tan
                    gradient.addColorStop(0.3, '#DEB887');  // Burlywood
                    gradient.addColorStop(0.7, '#CD853F');  // Peru
                    gradient.addColorStop(1, '#A0522D');    // Sienna
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.strokeStyle = '#8B4513';
                    this.ctx.lineWidth = 1.5;
                }
                
                // Draw main board
                this.ctx.fillRect(-w/2, -h/2, w, h);
                this.ctx.strokeRect(-w/2, -h/2, w, h);
                
                if (!isSelected) {
                    // Wood grain effect - more realistic
                    this.ctx.strokeStyle = '#A0522D';
                    this.ctx.lineWidth = 0.5;
                    this.ctx.globalAlpha = 0.6;
                    
                    // Longitudinal grain lines
                    const grainSpacing = Math.max(2, h / 20);
                    for (let i = -h/2 + grainSpacing; i < h/2; i += grainSpacing) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(-w/2 + 2, i + Math.sin(i * 0.1) * 0.5);
                        this.ctx.lineTo(w/2 - 2, i + Math.sin(i * 0.1) * 0.5);
                        this.ctx.stroke();
                    }
                    
                    // Add some knots and imperfections
                    this.ctx.fillStyle = '#8B4513';
                    this.ctx.globalAlpha = 0.3;
                    const numKnots = Math.floor(Math.random() * 3);
                    for (let i = 0; i < numKnots; i++) {
                        const knotX = (Math.random() - 0.5) * w * 0.6;
                        const knotY = (Math.random() - 0.5) * h * 0.6;
                        this.ctx.beginPath();
                        this.ctx.arc(knotX, knotY, 2 + Math.random() * 2, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    this.ctx.globalAlpha = 1;
                }
                
                // Board edge highlight
                if (!isSelected) {
                    this.ctx.strokeStyle = '#F5DEB3';
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeRect(-w/2 + 1, -h/2 + 1, w - 2, h - 2);
                }
                
                this.ctx.restore();
            }
            
            drawGrid() {
                const showGrid = document.getElementById('showGrid').checked;
                if (!showGrid) return;
                
                let gridSizeFeet;
                const gridSizeValue = document.getElementById('gridSize').value;
                
                if (gridSizeValue === 'custom') {
                    // Use custom input
                    const customSize = parseFloat(document.getElementById('customGridSize').value);
                    const unit = document.getElementById('gridUnit').value;
                    
                    if (unit === 'inches') {
                        gridSizeFeet = customSize / 12; // Convert inches to feet
                    } else {
                        gridSizeFeet = customSize; // Already in feet
                    }
                } else {
                    // Use preset dropdown value
                    gridSizeFeet = parseFloat(gridSizeValue);
                }
                
                const gridSpacing = gridSizeFeet * this.scale; // Convert feet to pixels
                
                // Don't draw grid if spacing is too small (less than 1 pixel)
                if (gridSpacing < 1) return;
                
                this.ctx.strokeStyle = '#d0d0d0';
                this.ctx.lineWidth = 0.5;
                
                // Make grid lines lighter for very fine grids
                if (gridSpacing < 5) {
                    this.ctx.strokeStyle = '#e0e0e0';
                    this.ctx.lineWidth = 0.25;
                }
                
                // Get the same snap grid origin that the deck uses
                const snapSpacing = this.snapGridSize * this.scale; // 1/8" grid in pixels
                
                // Find the offset to align visual grid with snap grid
                // We want the visual grid to align with the snap grid at the deck origin
                const baseX = 150;
                const baseY = 100;
                const snappedDeckPos = this.snapToGrid(baseX, baseY);
                
                // Calculate the offset needed to align grids
                const offsetX = snappedDeckPos.x % gridSpacing;
                const offsetY = snappedDeckPos.y % gridSpacing;
                
                // Draw vertical grid lines starting from the aligned offset
                for (let i = offsetX; i < this.canvas.width; i += gridSpacing) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(i, 0);
                    this.ctx.lineTo(i, this.canvas.height);
                    this.ctx.stroke();
                }
                
                // Draw lines in the negative direction too
                for (let i = offsetX - gridSpacing; i >= 0; i -= gridSpacing) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(i, 0);
                    this.ctx.lineTo(i, this.canvas.height);
                    this.ctx.stroke();
                }
                
                // Draw horizontal grid lines starting from the aligned offset
                for (let i = offsetY; i < this.canvas.height; i += gridSpacing) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, i);
                    this.ctx.lineTo(this.canvas.width, i);
                    this.ctx.stroke();
                }
                
                // Draw lines in the negative direction too
                for (let i = offsetY - gridSpacing; i >= 0; i -= gridSpacing) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, i);
                    this.ctx.lineTo(this.canvas.width, i);
                    this.ctx.stroke();
                }
            }
            
            drawSelectionBox() {
                this.ctx.strokeStyle = '#0066CC';
                this.ctx.fillStyle = 'rgba(0, 102, 204, 0.1)';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                
                const x = Math.min(this.boxStart.x, this.boxEnd.x);
                const y = Math.min(this.boxStart.y, this.boxEnd.y);
                const w = Math.abs(this.boxEnd.x - this.boxStart.x);
                const h = Math.abs(this.boxEnd.y - this.boxStart.y);
                
                this.ctx.fillRect(x, y, w, h);
                this.ctx.strokeRect(x, y, w, h);
                this.ctx.setLineDash([]);
            }
            
            updateBoardCount() {
                document.getElementById('boardCount').value = this.boards.length;
            }
            
            drawEdgeHandles(topEdge, rightEdge, bottomEdge, leftEdge, extWidth, extLength) {
                // Use same snapped position as deck outline
                const baseX = 150;
                const baseY = 100;
                const snappedDeckPos = this.snapToGrid(baseX, baseY);
                const x = snappedDeckPos.x;
                const y = snappedDeckPos.y;
                
                const te = topEdge * this.scale;
                const re = rightEdge * this.scale;
                const be = bottomEdge * this.scale;
                const le = leftEdge * this.scale;
                const ew = extWidth * this.scale;
                const el = extLength * this.scale;
                
                this.edgeHandles = [];
                
                // Main deck edges
                this.edgeHandles.push(
                    { id: 'top', x1: x, y1: y, x2: x + te, y2: y, type: 'horizontal', dimension: 'topEdge' },
                    { id: 'right', x1: x + te, y1: y, x2: x + te, y2: y + re, type: 'vertical', dimension: 'rightEdge' },
                    { id: 'bottom', x1: x + te - be, y1: y + re, x2: x + te, y2: y + re, type: 'horizontal', dimension: 'bottomEdge' },
                    { id: 'left', x1: x, y1: y, x2: x, y2: y + le, type: 'vertical', dimension: 'leftEdge' }
                );
                
                // Extension edges (if exists)
                if (extWidth > 0 && extLength > 0) {
                    this.edgeHandles.push(
                        { id: 'ext-right', x1: x + te, y1: y + re - el, x2: x + te + ew, y2: y + re - el, type: 'horizontal', dimension: 'extWidth' },
                        { id: 'ext-bottom', x1: x + te, y1: y + re - el, x2: x + te, y2: y + re, type: 'vertical', dimension: 'extLength' }
                    );
                }
                
                // Draw edge handles
                this.edgeHandles.forEach(handle => {
                    this.ctx.strokeStyle = handle === this.selectedEdge ? '#FF0000' : '#0066CC';
                    this.ctx.lineWidth = handle === this.selectedEdge ? 4 : 2;
                    this.ctx.setLineDash([]);
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(handle.x1, handle.y1);
                    this.ctx.lineTo(handle.x2, handle.y2);
                    this.ctx.stroke();
                    
                    // Draw dimension text
                    const midX = (handle.x1 + handle.x2) / 2;
                    const midY = (handle.y1 + handle.y2) / 2;
                    const value = handle.dimension === 'topEdge' ? topEdge :
                                 handle.dimension === 'rightEdge' ? rightEdge :
                                 handle.dimension === 'bottomEdge' ? bottomEdge :
                                 handle.dimension === 'leftEdge' ? leftEdge :
                                 handle.dimension === 'extWidth' ? extWidth : extLength;
                    
                    this.ctx.fillStyle = '#333';
                    this.ctx.font = 'bold 14px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    
                    // Position text based on edge type for better visibility
                    let textX = midX;
                    let textY = midY - 8;
                    
                    if (handle.id === 'left') {
                        // Left edge: position text to the left of the edge
                        textX = midX - 25;
                        textY = midY;
                        this.ctx.textAlign = 'right';
                    } else if (handle.id === 'right') {
                        // Right edge: position text to the right of the edge
                        textX = midX + 25;
                        textY = midY;
                        this.ctx.textAlign = 'left';
                    } else if (handle.id === 'bottom') {
                        // Bottom edge: position text below the edge
                        textX = midX;
                        textY = midY + 20;
                        this.ctx.textAlign = 'center';
                    } else if (handle.id === 'ext-right') {
                        // Extension right edge: position text above the edge to avoid overlap
                        textX = midX;
                        textY = midY - 15;
                        this.ctx.textAlign = 'center';
                    } else if (handle.id === 'ext-bottom') {
                        // Extension bottom edge: position text to the right to avoid overlap
                        textX = midX + 30;
                        textY = midY;
                        this.ctx.textAlign = 'left';
                    }
                    
                    this.ctx.fillText(`${value}'`, textX, textY);
                    
                    // Draw small handle squares
                    const handleSize = 6;
                    this.ctx.fillStyle = handle === this.selectedEdge ? '#FF0000' : '#0066CC';
                    this.ctx.fillRect(midX - handleSize/2, midY - handleSize/2, handleSize, handleSize);
                });
            }
            
            getEdgeAtPoint(x, y) {
                for (let handle of this.edgeHandles) {
                    const midX = (handle.x1 + handle.x2) / 2;
                    const midY = (handle.y1 + handle.y2) / 2;
                    const distance = Math.sqrt((x - midX) ** 2 + (y - midY) ** 2);
                    
                    if (distance < 15) { // 15 pixel tolerance
                        return handle;
                    }
                }
                return null;
            }
            
            showFloatingInput(target, type, x, y, label) {
                console.log('showFloatingInput called with:', { target, type, x, y, label });
                
                this.editingTarget = target;
                this.editingType = type;
                
                const floatingInput = document.getElementById('floatingInput');
                const inputLabel = document.getElementById('inputLabel');
                const widthInput = document.getElementById('widthInput');
                const lengthInput = document.getElementById('lengthInput');
                const edgeInput = document.getElementById('edgeInput');
                const edgeInputRow = document.getElementById('edgeInputRow');
                
                console.log('Dialog elements found:', { 
                    floatingInput: !!floatingInput, 
                    inputLabel: !!inputLabel,
                    widthInput: !!widthInput,
                    lengthInput: !!lengthInput 
                });
                
                inputLabel.textContent = label;
                
                if (type === 'board') {
                    console.log('Setting up board editing dialog');
                    // Show board inputs, hide edge input
                    const widthRow = floatingInput.querySelector('.dimension-row:nth-child(1)');
                    const lengthRow = floatingInput.querySelector('.dimension-row:nth-child(2)');
                    
                    console.log('Dimension rows found:', { widthRow: !!widthRow, lengthRow: !!lengthRow });
                    
                    if (widthRow) widthRow.style.display = 'flex';
                    if (lengthRow) lengthRow.style.display = 'flex';
                    edgeInputRow.style.display = 'none';
                    
                    const boardWidthInches = (target.width / this.scale * 12);
                    const boardLengthFeet = (target.height / this.scale);
                    
                    console.log('Board dimensions:', { boardWidthInches, boardLengthFeet });
                    
                    widthInput.value = boardWidthInches.toFixed(1);
                    lengthInput.value = boardLengthFeet.toFixed(1);
                    
                    widthInput.focus();
                } else if (type === 'edge') {
                    console.log('Setting up edge editing dialog');
                    // Show edge input, hide board inputs
                    const widthRow = floatingInput.querySelector('.dimension-row:nth-child(1)');
                    const lengthRow = floatingInput.querySelector('.dimension-row:nth-child(2)');
                    
                    if (widthRow) widthRow.style.display = 'none';
                    if (lengthRow) lengthRow.style.display = 'none';
                    edgeInputRow.style.display = 'flex';
                    
                    const currentValue = document.getElementById(target.dimension).value;
                    edgeInput.value = currentValue;
                    
                    edgeInput.focus();
                }
                
                console.log('Positioning dialog at:', { x, y });
                floatingInput.style.left = x + 'px';
                floatingInput.style.top = y + 'px';
                floatingInput.style.display = 'block';
                
                console.log('Dialog should now be visible. Current style:', {
                    display: floatingInput.style.display,
                    left: floatingInput.style.left,
                    top: floatingInput.style.top,
                    zIndex: window.getComputedStyle(floatingInput).zIndex
                });
            }
            
            initDialogDragging() {
                const titleBar = document.getElementById('titleBar');
                
                titleBar.addEventListener('mousedown', (e) => {
                    this.isDraggingDialog = true;
                    const dialog = document.getElementById('floatingInput');
                    const rect = dialog.getBoundingClientRect();
                    this.dialogDragOffset.x = e.clientX - rect.left;
                    this.dialogDragOffset.y = e.clientY - rect.top;
                    e.preventDefault();
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.isDraggingDialog) {
                        const dialog = document.getElementById('floatingInput');
                        dialog.style.left = (e.clientX - this.dialogDragOffset.x) + 'px';
                        dialog.style.top = (e.clientY - this.dialogDragOffset.y) + 'px';
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    this.isDraggingDialog = false;
                });
            }
            
            showDimensionInput(edge) {
                // Center the dialog on screen
                const dialogWidth = 220;
                const dialogHeight = 150;
                const centerX = window.innerWidth / 2 - dialogWidth / 2;
                const centerY = window.innerHeight / 2 - dialogHeight / 2;
                
                this.showFloatingInput(
                    edge,
                    'edge',
                    centerX,
                    centerY,
                    `Edit ${edge.dimension.replace(/([A-Z])/g, ' $1').toLowerCase()}:`
                );
            }
            
            showBoardDimensionInput(board, x, y) {
                const rect = this.canvas.getBoundingClientRect();
                
                // Position dialog to the right of the canvas, but ensure it's visible
                let dialogX = rect.right + 10;
                let dialogY = rect.top + 50;
                
                // If dialog would be off-screen, position it differently
                if (dialogX + 250 > window.innerWidth) {
                    dialogX = rect.left + x + 20; // Position near the clicked board
                    dialogY = rect.top + y - 50;
                }
                
                console.log('Double-click detected on board, showing dimension input');
                
                this.showFloatingInput(
                    board,
                    'board',
                    dialogX,
                    dialogY,
                    'Edit Board Dimensions:'
                );
            }
            
            createBoard(x, y, width = null, length = null) {
                // Calculate dimensions with fallback defaults
                if (!width) {
                    const boardWidthElement = document.getElementById('boardWidth');
                    const boardWidthValue = boardWidthElement?.value || '5.5'; // Default to 2x6 (5.5")
                    width = parseFloat(boardWidthValue) / 12; // Convert inches to feet
                }
                if (!length) {
                    const boardLengthElement = document.getElementById('boardLength');
                    const boardLengthValue = boardLengthElement?.value || '8'; // Default to 8 feet
                    length = parseFloat(boardLengthValue) || 8; // Fallback to 8 if parsing fails
                }
                
                // Apply snapping only to board position, not dimensions
                const snapped = this.snapToGrid(x, y);
                
                return {
                    x: snapped.x,
                    y: snapped.y,
                    width: width * this.scale,  // Use calculated width
                    height: length * this.scale, // Use calculated length
                    rotation: 0,
                    selected: false
                };
            }
            
            handleMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                
                // Check for panning (middle mouse button or space + left click)
                if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
                    this.isPanning = true;
                    this.panStart.x = screenX;
                    this.panStart.y = screenY;
                    this.canvas.style.cursor = 'grabbing';
                    e.preventDefault();
                    return;
                }
                
                // Convert to world coordinates for all other interactions
                const worldPos = this.screenToWorld(screenX, screenY);
                const x = worldPos.x;
                const y = worldPos.y;
                
                // Check if clicking on an edge handle first
                const clickedEdge = this.getEdgeAtPoint(x, y);
                if (clickedEdge) {
                    this.selectedEdge = clickedEdge;
                    this.showDimensionInput(clickedEdge);
                    this.drawDeck();
                    return;
                }
                
                // Check if clicking on a board
                this.selectedBoard = null;
                let clickedBoard = null;
                
                for (let i = this.boards.length - 1; i >= 0; i--) {
                    if (this.isPointInBoard(x, y, this.boards[i])) {
                        clickedBoard = this.boards[i];
                        break;
                    }
                }
                
                if (clickedBoard) {
                    // If double-click, edit board dimensions
                    if (e.detail === 2) {
                        console.log('Double-click detected on board:', clickedBoard);
                        this.showBoardDimensionInput(clickedBoard, x, y);
                        return;
                    }
                    // If ctrl/cmd key is held, add to selection
                    else if (e.ctrlKey || e.metaKey) {
                        if (this.selectedBoards.includes(clickedBoard)) {
                            this.selectedBoards = this.selectedBoards.filter(b => b !== clickedBoard);
                            clickedBoard.selected = false;
                        } else {
                            this.selectedBoards.push(clickedBoard);
                            clickedBoard.selected = true;
                        }
                    } else {
                        // Single selection or start dragging selected group
                        if (this.selectedBoards.includes(clickedBoard)) {
                            // Start dragging the group
                            this.isDragging = true;
                            this.selectedBoard = clickedBoard;
                            this.dragOffset.x = x - clickedBoard.x;
                            this.dragOffset.y = y - clickedBoard.y;
                            
                            // Save state before dragging
                            this.saveState();
                        } else {
                            // Clear previous selection and select this board
                            this.boards.forEach(b => b.selected = false);
                            this.selectedBoards = [clickedBoard];
                            clickedBoard.selected = true;
                            this.selectedBoard = clickedBoard;
                            this.isDragging = true;
                            this.dragOffset.x = x - clickedBoard.x;
                            this.dragOffset.y = y - clickedBoard.y;
                            
                            // Save state before dragging
                            this.saveState();
                        }
                    }
                } else {
                    // Start box selection
                    this.isBoxSelecting = true;
                    this.boxStart.x = x;
                    this.boxStart.y = y;
                    this.boxEnd.x = x;
                    this.boxEnd.y = y;
                    
                    // Clear selection if not holding ctrl
                    if (!e.ctrlKey && !e.metaKey) {
                        this.boards.forEach(b => b.selected = false);
                        this.selectedBoards = [];
                    }
                }
                
                // Clear edge selection
                this.selectedEdge = null;
                
                this.drawDeck();
            }
            
            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                
                // Handle panning
                if (this.isPanning) {
                    const deltaX = screenX - this.panStart.x;
                    const deltaY = screenY - this.panStart.y;
                    
                    this.viewOffset.x += deltaX;
                    this.viewOffset.y += deltaY;
                    
                    this.panStart.x = screenX;
                    this.panStart.y = screenY;
                    
                    this.drawDeck();
                    return;
                }
                
                // Convert to world coordinates for other interactions
                const worldPos = this.screenToWorld(screenX, screenY);
                const x = worldPos.x;
                const y = worldPos.y;
                
                if (this.isDragging && this.selectedBoard) {
                    // Calculate movement delta with snapping
                    const rawX = x - this.dragOffset.x;
                    const rawY = y - this.dragOffset.y;
                    const snapped = this.snapToGrid(rawX, rawY);
                    const newX = snapped.x;
                    const newY = snapped.y;
                    
                    const deltaX = newX - this.selectedBoard.x;
                    const deltaY = newY - this.selectedBoard.y;
                    
                    // Store original positions of all selected boards
                    const originalPositions = this.selectedBoards.map(board => ({
                        board: board,
                        x: board.x,
                        y: board.y
                    }));
                    
                    // Move all selected boards
                    this.selectedBoards.forEach(board => {
                        board.x += deltaX;
                        board.y += deltaY;
                    });
                    
                    // Apply object snapping to the main selected board
                    const wasSnapped = this.snapToNearbyObjects(this.selectedBoard);
                    
                    // Check for overlaps (but be more lenient if boards were snapped)
                    let hasOverlap = false;
                    if (!wasSnapped) { // Only check overlap if not snapped
                        for (let board of this.selectedBoards) {
                            if (this.wouldOverlap(board, ...this.selectedBoards)) {
                                hasOverlap = true;
                                break;
                            }
                        }
                    } else {
                        // If snapped, check for significant overlap (not just touching)
                        for (let board of this.selectedBoards) {
                            if (this.wouldSignificantlyOverlap(board, ...this.selectedBoards)) {
                                hasOverlap = true;
                                break;
                            }
                        }
                    }
                    
                    // Revert if overlap detected
                    if (hasOverlap) {
                        originalPositions.forEach(({board, x, y}) => {
                            board.x = x;
                            board.y = y;
                        });
                    }
                    
                    this.drawDeck();
                } else if (this.isBoxSelecting) {
                    // Update box selection
                    this.boxEnd.x = x;
                    this.boxEnd.y = y;
                    
                    // Select boards within box
                    const minX = Math.min(this.boxStart.x, this.boxEnd.x);
                    const maxX = Math.max(this.boxStart.x, this.boxEnd.x);
                    const minY = Math.min(this.boxStart.y, this.boxEnd.y);
                    const maxY = Math.max(this.boxStart.y, this.boxEnd.y);
                    
                    this.boards.forEach(board => {
                        const inBox = board.x >= minX && board.x <= maxX && 
                                     board.y >= minY && board.y <= maxY;
                        
                        if (inBox && !this.selectedBoards.includes(board)) {
                            this.selectedBoards.push(board);
                            board.selected = true;
                        }
                    });
                    
                    this.drawDeck();
                }
            }
            
            handleMouseUp() {
                this.isDragging = false;
                this.isBoxSelecting = false;
                this.isPanning = false;
                this.canvas.style.cursor = 'grab';
            }
            
            handleRightClick(e) {
                e.preventDefault();
                const rect = this.canvas.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                const worldPos = this.screenToWorld(screenX, screenY);
                
                // Find board to rotate
                for (let board of this.boards) {
                    if (this.isPointInBoard(worldPos.x, worldPos.y, board)) {
                        board.rotation += Math.PI / 2;
                        this.drawDeck();
                        break;
                    }
                }
            }
            
            handleWheel(e) {
                e.preventDefault();
                
                // Simple zoom by adjusting scale (optional enhancement)
                // For now, just prevent default scrolling behavior
                // Could add zoom functionality here later
            }
            
            isPointInBoard(px, py, board) {
                const dx = px - board.x;
                const dy = py - board.y;
                const cos = Math.cos(-board.rotation);
                const sin = Math.sin(-board.rotation);
                const localX = dx * cos - dy * sin;
                const localY = dx * sin + dy * cos;
                
                return Math.abs(localX) <= board.width / 2 && Math.abs(localY) <= board.height / 2;
            }
            
            // Check if two boards overlap
            boardsOverlap(board1, board2) {
                // Get the corners of each board
                const corners1 = this.getBoardCorners(board1);
                const corners2 = this.getBoardCorners(board2);
                
                // Check if any corner of board1 is inside board2, or vice versa
                for (let corner of corners1) {
                    if (this.isPointInBoard(corner.x, corner.y, board2)) {
                        return true;
                    }
                }
                for (let corner of corners2) {
                    if (this.isPointInBoard(corner.x, corner.y, board1)) {
                        return true;
                    }
                }
                
                return false;
            }
            
            // Get the four corners of a board
            getBoardCorners(board) {
                const cos = Math.cos(board.rotation);
                const sin = Math.sin(board.rotation);
                const hw = board.width / 2;
                const hh = board.height / 2;
                
                return [
                    { x: board.x + (-hw * cos - -hh * sin), y: board.y + (-hw * sin + -hh * cos) },
                    { x: board.x + (hw * cos - -hh * sin), y: board.y + (hw * sin + -hh * cos) },
                    { x: board.x + (hw * cos - hh * sin), y: board.y + (hw * sin + hh * cos) },
                    { x: board.x + (-hw * cos - hh * sin), y: board.y + (-hw * sin + hh * cos) }
                ];
            }
            
            // Check if a board would overlap with any existing board
            wouldOverlap(board, excludeBoard = null) {
                for (let otherBoard of this.boards) {
                    if (otherBoard === excludeBoard) continue;
                    if (this.boardsOverlap(board, otherBoard)) {
                        return true;
                    }
                }
                return false;
            }
            
            saveState() {
                // Deep clone the current board state
                const state = this.boards.map(board => ({
                    x: board.x,
                    y: board.y,
                    width: board.width,
                    height: board.height,
                    rotation: board.rotation,
                    selected: false // Don't save selection state
                }));
                
                this.undoStack.push(state);
                
                // Limit undo stack size
                if (this.undoStack.length > this.maxUndoSteps) {
                    this.undoStack.shift();
                }
            }
            
            undo() {
                if (this.undoStack.length === 0) return;
                
                const previousState = this.undoStack.pop();
                this.boards = previousState.map(boardData => ({
                    ...boardData,
                    selected: false
                }));
                this.selectedBoards = [];
                this.drawDeck();
            }
            
            snapToGrid(x, y) {
                if (!this.snapEnabled) return { x, y };
                
                const snapSpacing = this.snapGridSize * this.scale; // Convert to pixels
                
                // Snap to nearest grid point
                const snappedX = Math.round(x / snapSpacing) * snapSpacing;
                const snappedY = Math.round(y / snapSpacing) * snapSpacing;
                
                return { x: snappedX, y: snappedY };
            }
            
            // Check if a board would significantly overlap (more than just touching)
            wouldSignificantlyOverlap(board, ...excludeBoards) {
                const overlapTolerance = 3; // pixels - allow small overlaps for snapped boards
                
                for (let otherBoard of this.boards) {
                    if (excludeBoards.includes(otherBoard)) continue;
                    
                    // Get board boundaries with tolerance
                    const board1Left = board.x - board.width / 2 + overlapTolerance;
                    const board1Right = board.x + board.width / 2 - overlapTolerance;
                    const board1Top = board.y - board.height / 2 + overlapTolerance;
                    const board1Bottom = board.y + board.height / 2 - overlapTolerance;
                    
                    const board2Left = otherBoard.x - otherBoard.width / 2 + overlapTolerance;
                    const board2Right = otherBoard.x + otherBoard.width / 2 - overlapTolerance;
                    const board2Top = otherBoard.y - otherBoard.height / 2 + overlapTolerance;
                    const board2Bottom = otherBoard.y + otherBoard.height / 2 - overlapTolerance;
                    
                    // Check if boards significantly overlap
                    if (board1Left < board2Right && board1Right > board2Left &&
                        board1Top < board2Bottom && board1Bottom > board2Top) {
                        return true;
                    }
                }
                return false;
            }
            
            snapToNearbyObjects(board) {
                if (!this.snapEnabled) return false;
                
                const snapDistance = 15; // pixels
                let snapped = false;
                
                // Get deck boundaries using snapped position
                const baseX = 150;
                const baseY = 100;
                const snappedDeckPos = this.snapToGrid(baseX, baseY);
                const deckX = snappedDeckPos.x;
                const deckY = snappedDeckPos.y;
                
                // Get all deck dimensions for irregular quadrilateral
                const topEdge = parseFloat(document.getElementById('topEdge').value) * this.scale;
                const rightEdge = parseFloat(document.getElementById('rightEdge').value) * this.scale;
                const bottomEdge = parseFloat(document.getElementById('bottomEdge').value) * this.scale;
                const leftEdge = parseFloat(document.getElementById('leftEdge').value) * this.scale;
                
                // Calculate actual deck boundaries for irregular quadrilateral
                const deckTopLeft = { x: deckX, y: deckY };
                const deckTopRight = { x: deckX + topEdge, y: deckY };
                const deckBottomRight = { x: deckX + topEdge, y: deckY + rightEdge };
                const deckBottomLeft = { x: deckX + topEdge - bottomEdge, y: deckY + rightEdge };
                const deckLeftBottom = { x: deckX, y: deckY + leftEdge };
                
                // Snap to deck edges
                const boardLeft = board.x - board.width / 2;
                const boardRight = board.x + board.width / 2;
                const boardTop = board.y - board.height / 2;
                const boardBottom = board.y + board.height / 2;
                
                // Snap to left deck edge (vertical line from top-left to left-bottom)
                if (Math.abs(boardLeft - deckX) < snapDistance && 
                    board.y >= deckY && board.y <= deckY + leftEdge) {
                    board.x = deckX + board.width / 2;
                    snapped = true;
                }
                
                // Snap to top deck edge (horizontal line from top-left to top-right)
                if (Math.abs(boardTop - deckY) < snapDistance && 
                    board.x >= deckX && board.x <= deckX + topEdge) {
                    board.y = deckY + board.height / 2;
                    snapped = true;
                }
                
                // Snap to right deck edge (vertical line from top-right to bottom-right)
                if (Math.abs(boardRight - (deckX + topEdge)) < snapDistance && 
                    board.y >= deckY && board.y <= deckY + rightEdge) {
                    board.x = deckX + topEdge - board.width / 2;
                    snapped = true;
                }
                
                // Snap to bottom deck edge (horizontal line from bottom-left to bottom-right)
                if (Math.abs(boardBottom - (deckY + rightEdge)) < snapDistance && 
                    board.x >= (deckX + topEdge - bottomEdge) && board.x <= (deckX + topEdge)) {
                    board.y = deckY + rightEdge - board.height / 2;
                    snapped = true;
                }
                
                // Snap to other boards
                for (let otherBoard of this.boards) {
                    if (otherBoard === board || this.selectedBoards.includes(otherBoard)) continue;
                    
                    const otherLeft = otherBoard.x - otherBoard.width / 2;
                    const otherRight = otherBoard.x + otherBoard.width / 2;
                    const otherTop = otherBoard.y - otherBoard.height / 2;
                    const otherBottom = otherBoard.y + otherBoard.height / 2;
                    
                    // Recalculate board edges after potential deck snapping
                    const newBoardLeft = board.x - board.width / 2;
                    const newBoardRight = board.x + board.width / 2;
                    const newBoardTop = board.y - board.height / 2;
                    const newBoardBottom = board.y + board.height / 2;
                    
                    // Snap to board edges
                    // Left edge to right edge
                    if (Math.abs(newBoardLeft - otherRight) < snapDistance && 
                        Math.abs(board.y - otherBoard.y) < board.height / 2 + otherBoard.height / 2) {
                        board.x = otherRight + board.width / 2;
                        snapped = true;
                    }
                    // Right edge to left edge
                    else if (Math.abs(newBoardRight - otherLeft) < snapDistance && 
                             Math.abs(board.y - otherBoard.y) < board.height / 2 + otherBoard.height / 2) {
                        board.x = otherLeft - board.width / 2;
                        snapped = true;
                    }
                    
                    // Top edge to bottom edge
                    if (Math.abs(newBoardTop - otherBottom) < snapDistance && 
                        Math.abs(board.x - otherBoard.x) < board.width / 2 + otherBoard.width / 2) {
                        board.y = otherBottom + board.height / 2;
                        snapped = true;
                    }
                    // Bottom edge to top edge
                    else if (Math.abs(newBoardBottom - otherTop) < snapDistance && 
                             Math.abs(board.x - otherBoard.x) < board.width / 2 + otherBoard.width / 2) {
                        board.y = otherTop - board.height / 2;
                        snapped = true;
                    }
                }
                
                return snapped;
            }
            
            resizeCanvas() {
                const container = document.querySelector('.canvas-container');
                const rect = container.getBoundingClientRect();
                
                // Set canvas size to fill the container minus padding
                this.canvas.width = rect.width - 40; // Account for 20px padding on each side
                this.canvas.height = rect.height - 40;
                
                // Redraw after resize
                if (this.boards) {
                    this.drawDeck();
                }
            }
        }
        
        // Initialize the visualizer
        const deckViz = new DeckVisualizer();
        
        // Collapsible sections functionality
        function toggleSection(sectionId) {
            const content = document.getElementById(sectionId);
            const header = content.previousElementSibling;
            
            content.classList.toggle('collapsed');
            
            // Update header text to show expand/collapse state
            const isCollapsed = content.classList.contains('collapsed');
            const originalText = header.textContent.replace(' ▼', '').replace(' ▶', '');
            header.textContent = originalText + (isCollapsed ? ' ▶' : ' ▼');
        }
        
        function toggleMainPanel() {
            const mainControls = document.getElementById('mainControls');
            const mainToggle = document.getElementById('mainToggle');
            
            mainControls.classList.toggle('collapsed');
            mainToggle.textContent = mainControls.classList.contains('collapsed') ? '▶' : '▼';
        }
        
        // Dimension adjustment functionality
        function adjustDimension(type, delta) {
            if (type === 'width') {
                const input = document.getElementById('widthInput');
                const newValue = Math.max(0.5, parseFloat(input.value) + delta);
                input.value = newValue.toFixed(1);
            } else if (type === 'length') {
                const input = document.getElementById('lengthInput');
                const newValue = Math.max(0.5, parseFloat(input.value) + delta);
                input.value = newValue.toFixed(1);
            } else if (type === 'edge') {
                const input = document.getElementById('edgeInput');
                const newValue = Math.max(1, parseFloat(input.value) + delta);
                input.value = newValue.toFixed(1);
            }
        }
        
        // Floating input functionality
        function applyFloatingInput() {
            if (deckViz.editingType === 'edge') {
                const edgeInput = document.getElementById('edgeInput');
                const value = parseFloat(edgeInput.value);
                
                if (value > 0) {
                    const edge = deckViz.editingTarget;
                    document.getElementById(edge.dimension).value = value;
                    deckViz.updateLayout();
                }
            } else if (deckViz.editingType === 'board') {
                const widthInput = document.getElementById('widthInput');
                const lengthInput = document.getElementById('lengthInput');
                
                const widthInches = parseFloat(widthInput.value);
                const lengthFeet = parseFloat(lengthInput.value);
                
                if (widthInches > 0 && lengthFeet > 0) {
                    const board = deckViz.editingTarget;
                    
                    board.width = (widthInches / 12) * deckViz.scale; // Convert inches to feet, then to pixels
                    board.height = lengthFeet * deckViz.scale; // Convert feet to pixels
                    
                    deckViz.drawDeck();
                }
            }
            
            hideFloatingInput();
        }
        
        function hideFloatingInput() {
            document.getElementById('floatingInput').style.display = 'none';
            deckViz.editingTarget = null;
            deckViz.editingType = null;
        }
        
        // Keyboard event handlers
        document.addEventListener('keydown', function(e) {
            const floatingInput = document.getElementById('floatingInput');
            
            // Handle floating input dialog
            if (floatingInput.style.display === 'block') {
                if (e.key === 'Enter') {
                    applyFloatingInput();
                } else if (e.key === 'Escape') {
                    hideFloatingInput();
                }
                return;
            }
            
            // Copy/Paste functionality
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'c' || e.key === 'C') {
                    e.preventDefault();
                    copySelectedBoards();
                } else if (e.key === 'v' || e.key === 'V') {
                    e.preventDefault();
                    pasteBoards();
                } else if (e.key === 'd' || e.key === 'D') {
                    e.preventDefault();
                    duplicateSelectedBoards();
                } else if (e.key === 'z' || e.key === 'Z') {
                    e.preventDefault();
                    deckViz.undo();
                }
            }
            
            // Delete selected boards
            if (e.key === 'Delete' || e.key === 'Backspace') {
                e.preventDefault();
                removeSelectedBoards();
            }
        });
        
        // Pattern functions
        function applyPattern(pattern) {
            deckViz.saveState(); // Save state before applying pattern
            
            deckViz.boards = [];
            const topEdge = parseFloat(document.getElementById('topEdge').value);
            const rightEdge = parseFloat(document.getElementById('rightEdge').value);
            const boardWidth = parseFloat(document.getElementById('boardWidth').value) / 12;
            const boardGap = parseFloat(document.getElementById('boardGap').value) / 12;
            const boardDirection = document.getElementById('boardDirection').value;
            
            // Use snapped deck position
            const baseX = 150;
            const baseY = 100;
            const snappedDeckPos = deckViz.snapToGrid(baseX, baseY);
            const startX = snappedDeckPos.x + 1 * deckViz.scale;
            const startY = snappedDeckPos.y + 1 * deckViz.scale;
            
            if (pattern === 'straight') {
                if (boardDirection === 'vertical') {
                    // Vertical boards (running left to right)
                    const spacing = (boardWidth + boardGap) * deckViz.scale;
                    const numBoards = Math.floor((topEdge - 2) / (boardWidth + boardGap));
                    
                    for (let i = 0; i < numBoards; i++) {
                        const board = deckViz.createBoard(
                            startX + i * spacing + spacing/2,
                            startY + (rightEdge * deckViz.scale) / 2,
                            boardWidth,
                            rightEdge - 2
                        );
                        deckViz.boards.push(board);
                    }
                } else {
                    // Horizontal boards (running front to back)
                    const spacing = (boardWidth + boardGap) * deckViz.scale;
                    const numBoards = Math.floor((rightEdge - 2) / (boardWidth + boardGap));
                    
                    for (let i = 0; i < numBoards; i++) {
                        const board = deckViz.createBoard(
                            startX + (topEdge * deckViz.scale) / 2,
                            startY + i * spacing + spacing/2,
                            boardWidth,
                            topEdge - 2
                        );
                        board.rotation = Math.PI / 2;
                        deckViz.boards.push(board);
                    }
                }
            }
            
            deckViz.drawDeck();
        }
        
        function resetLayout() {
            deckViz.boards = [];
            deckViz.drawDeck();
        }
        
        function addRandomBoard() {
            deckViz.saveState(); // Save state before adding
            
            let attempts = 0;
            let board;
            
            // Try to find a non-overlapping position
            do {
                board = deckViz.createBoard(
                    200 + Math.random() * 600,
                    150 + Math.random() * 500
                );
                attempts++;
            } while (deckViz.wouldOverlap(board) && attempts < 50);
            
            // Only add if we found a valid position
            if (attempts < 50) {
                deckViz.boards.push(board);
                deckViz.drawDeck();
            } else {
                alert("Could not find space for a new board. Try clearing some space first.");
            }
        }
        
        function addMultipleBoards(count) {
            deckViz.saveState(); // Save state before adding
            
            let addedCount = 0;
            for (let i = 0; i < count; i++) {
                let attempts = 0;
                let board;
                
                // Try to find a non-overlapping position
                do {
                    board = deckViz.createBoard(
                        200 + Math.random() * 700,
                        150 + Math.random() * 600
                    );
                    attempts++;
                } while (deckViz.wouldOverlap(board) && attempts < 20);
                
                // Only add if we found a valid position
                if (attempts < 20) {
                    deckViz.boards.push(board);
                    addedCount++;
                } else {
                    break; // Stop trying if we can't find space
                }
            }
            
            if (addedCount < count) {
                alert(`Could only add ${addedCount} out of ${count} boards due to space constraints.`);
            }
            
            deckViz.drawDeck();
        }
        
        function removeSelectedBoards() {
            if (deckViz.selectedBoards.length > 0) {
                deckViz.saveState(); // Save state before removing
            }
            
            deckViz.boards = deckViz.boards.filter(board => !deckViz.selectedBoards.includes(board));
            deckViz.selectedBoards = [];
            deckViz.boards.forEach(b => b.selected = false);
            deckViz.drawDeck();
        }
        
        // Copy/Paste functionality
        function copySelectedBoards() {
            if (deckViz.selectedBoards.length === 0) {
                alert('No boards selected to copy');
                return;
            }
            
            deckViz.clipboard = deckViz.selectedBoards.map(board => ({
                width: board.width,
                height: board.height,
                rotation: board.rotation
            }));
            
            console.log(`Copied ${deckViz.clipboard.length} board(s) to clipboard`);
        }
        
        function pasteBoards() {
            if (deckViz.clipboard.length === 0) {
                alert('No boards in clipboard to paste');
                return;
            }
            
            deckViz.saveState(); // Save state before pasting
            
            // Clear current selection
            deckViz.selectedBoards.forEach(b => b.selected = false);
            deckViz.selectedBoards = [];
            
            const offsetX = 60; // Offset for pasted boards
            const offsetY = 60;
            
            deckViz.clipboard.forEach(clipboardBoard => {
                let attempts = 0;
                let newBoard;
                
                do {
                    newBoard = deckViz.createBoard(
                        300 + Math.random() * 400 + offsetX,
                        200 + Math.random() * 300 + offsetY,
                        clipboardBoard.width / deckViz.scale, // Fix: Just convert pixels to feet
                        clipboardBoard.height / deckViz.scale
                    );
                    newBoard.rotation = clipboardBoard.rotation;
                    attempts++;
                } while (deckViz.wouldOverlap(newBoard) && attempts < 20);
                
                if (attempts < 20) {
                    deckViz.boards.push(newBoard);
                    deckViz.selectedBoards.push(newBoard);
                    newBoard.selected = true;
                }
            });
            
            deckViz.drawDeck();
            console.log(`Pasted ${deckViz.selectedBoards.length} board(s)`);
        }
        
        function duplicateSelectedBoards() {
            if (deckViz.selectedBoards.length === 0) {
                alert('No boards selected to duplicate');
                return;
            }
            
            deckViz.saveState(); // Save state before duplicating
            
            const originalSelection = [...deckViz.selectedBoards];
            
            // Clear current selection
            deckViz.selectedBoards.forEach(b => b.selected = false);
            deckViz.selectedBoards = [];
            
            const offsetX = 40;
            const offsetY = 40;
            
            originalSelection.forEach(originalBoard => {
                const newBoard = deckViz.createBoard(
                    originalBoard.x + offsetX,
                    originalBoard.y + offsetY,
                    originalBoard.width / deckViz.scale, // Fix: Just convert pixels to feet
                    originalBoard.height / deckViz.scale
                );
                newBoard.rotation = originalBoard.rotation;
                
                // Check for overlap and adjust position if needed
                let attempts = 0;
                while (deckViz.wouldOverlap(newBoard) && attempts < 10) {
                    newBoard.x += 20;
                    newBoard.y += 20;
                    attempts++;
                }
                
                if (attempts < 10) {
                    deckViz.boards.push(newBoard);
                    deckViz.selectedBoards.push(newBoard);
                    newBoard.selected = true;
                }
            });
            
            deckViz.drawDeck();
            console.log(`Duplicated ${deckViz.selectedBoards.length} board(s)`);
        }
        
        // Start with no boards (user requested default of 0)
        // setTimeout(() => applyPattern('straight'), 100);
    </script>
</body>
</html>